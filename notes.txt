# Python 101

## External Links
- <https://www.python.org/>
- <https://docs.python.org/3/>
- <https://www.python.org/dev/peps/>
- <https://developers.google.com/edu/python/>
- <https://www.pythoncheatsheet.org/>
- <https://docs.python.org/3/library/functools.html>
  Functional Programming: partial funcs., lru_cache ("memoization"), iterable reduce (to value), ...

## Magazines/Blogs
- <https://realpython.com/>

## Bibliography
- <https://wiki.python.org/moin/PythonBooks>
- <https://scaling-python.com/>
- <https://serious-python.com/index.html>

## Zen of programming
- Avoid the Billion dolar mistake:<br/>
  <https://en.wikipedia.org/wiki/Tony_Hoare>
  Don't use Null/None values. Use default values instead.
- Premature optimization is the root of all evil
  <https://en.wikipedia.org/wiki/Program_optimization#When_to_optimize>
  Don't expend time saving CPU instructions until you are sure that such instructions
  are executed hundreds of thousands of times in a seconds for long periods of time.
  HINT: In most scenarios, your CPU waste more time idle waiting for data that processing it.
    Put you data close to your CPU to make things "run fast".
    (GPU work fast by using many slow CPUs with isolated RAM close to each CPU )
- Inmutable structures will not fail once build. Mutable will (sometimes).
- An exception that can be fixed in code is not an exception, is a
  contemplated state. (It's just an state that you don't like that
  much). Use normal return values indicating the contemplated state
  - An exception that can NOT be fixed, can NOT be fixed.
  - If the software is wrong, your program must inform the
    developer (assert, log and popup "sorry the developer is an idiot")
  - If the hardware/network is wrong, your program  must inform the
    IT admin (log and popup "sorry, it's not your fault, System admin is an idiot")
  - If the user is wrong, your program must inform the user
    (popup "sorry, you are an idiot")
- What you call a "CPU" is actually a Turing Machine <br/>
  <https://en.wikipedia.org/wiki/Turing_machine>:
  - A Turing Machine is single threaded and operates on a single tape.
  - All the infinite algorithms that one can imagine are single
    threaded and can be resolved by a Turing Machine with enough memory
    and time (maybe infinite memory and time).
  - Multiprocess means "many turing machines running at the same time".
  - Multihread means "many turing machines fighting each other",
    but in rare occasions threads can be orchestated to build a
    new and faster Turing Machine. If you don't now what that means
    DO NOT USE thread.
  - In case of doubt, do NOT use multithread
  - I cheated you. The Turing machine doesn't exists. Real CPUs needs data
    from external systems and writes computation results
    to external systems. That's what we call I/O (Input/Output).
  - If data takes time to arrive you can try to use the
    Touring Machine for other tasks for which input data is
    already available. That's what we call Asyncrhonous I/O.
  - Algorithms plus data structures == Program

## Zen of Python
* <https://www.python.org/dev/peps/pep-0020/>
>>> import this
The Zen of Python, by Tim Peters
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than  right  now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!


# Learn X in Y min  [[{python.101]]

<!-- { --> 
```

  # ------------------------- Float vs Decimal vs Fraction --------

  from decimal import Decimal
  from fractions import Fraction

  a1 = 0.1    ; a2 = Decimal('0.1')       ; a3 = Fraction(1,10)
  b1 = 0.2    ; b2 = Decimal('0.2')       ; b3 = Fraction(2,10)
  c1 = 0.3    ; c2 = Decimal('0.3')       ; c3 = Fraction(3,10)

  c1 == a1+b1 ; c2 == a2+b2               ; c3 == a3+b3 ;
  #  FALSE    ; TRUE                      ; TRUE
  #             Recommended for Finances 
                (precission in decimals 
                 known a priori. Def: 28)



  # ------- 'f' Strings(3.6) --------------------------------
  # Recomended over any other "old" option
  userVar = "Franky"
  mensaje = f"Hello {userVar}!"
  

  # ------- Enums (3.4) -------------------------------------
  from enum import Enum, auto           

  class OperatingSystem(Enum):
      LINUX     = auto()
      MACOSX    = auto()
      WINDOWSNT = auto()
      HAIKU     = auto()
      SOLARIS   = auto()

  # ------- Error Handling/Exception Handling ---------------
  def spam(divideBy):
    try:
      if assertValue == False:
          raise  Exception('This is the error message.')
      return myIntVar / divideBy
    except ZeroDivisionError as e:
      print('Error: Invalid argument: {}'.format(e))
    except Exception as err:
      print f('trapped exception {err}')   # ← Print exception
      with open('log.txt', 'w') as fA:
          fA.write(traceback.format_exc()) # ← Write traceback to file
    finally :
      print('Either there was an error or a division')

  # ------ Assertions  ------------------------------------
  status = 'open'
  assert status == 'open', 'Status expected to be "open"'

  code should NOT handle assert statements with try and except
  It must fail-fast and crash!!
  <https://en.wikipedia.org/wiki/Fail-fast>

# functions [[{101.functions]]

  ```
  def foo():                     #  <·· Function definition
    """
    This is a function docstring
    You can also use:
    ''' Function Docstring '''
    """
    ...
    return result

   add =  lambda  x, y: x + y   # <·· Lambda: Function with local stack 
                                #     + "context" stack.
                                #       └──────┬──────┘ 
                                #       stack of "outer" function while 
                                #       building the lambda
                  └──┴─··········· func. args
   ( lambda  x, y: x + y)(5, 3) # 8

   def build_adder(n):          # <·· function building(returning) new lambdas
       return lambda x: x + n   #     Each lambda keeps in stack the different n
   plus_3 = build_adder(3)      #     of each invocation to the outer function
  ```

## (args) vs *(kwargs)

- In funct. declaration:
  - '*'  means "pack all remaining positional arguments into a tuple named <name>"
  - '**' means "pack all remaining positional arguments into a dictionary named <name>"

- In funct. call:
  - '*'  means "unpack tuple or list named <name> to positional arguments at this position"
  - '**' mean: "unpack dictionary    named <name> to positional arguments at this position"

  ```
  - Wrapper function around any other function:
  def forward(f,  args,  *kwargs):
      return f( args,  *kwargs)
  ```
[[101.functions}]]

# Strings [[{101.strings,strings]]


  ```
  'Alice' 'Bob' #  <·· String concatenation ('AliceBob')
                #  Note: Avoid '+' operator for string concatenation. 
                #  Prefer string formatting.
 'Alice' * 5    # <·· ( 'AliceAliceAliceAliceAlice' )

 'Hello Mr {} {} """    #  <··  String format (2.7+) {}, ...:
 .format(name, surname) #        Replaces the (discouraged) '%' operator
                        #        'Hello Mr %s' % name
 See the more advanced f-strings (3.6+)

 Escape char   Prints as ..
 ---------     ------------
 \'            Single quote
 \"            Double quote
 \t            Tab
 \n            Newline
 \\            Backslash

        ┌·· Raw Strings : ignores all escape characters (used for regex mostly)
  print(r"That is Carol\'s cat.")

  # ----- multi line string  ------
  myMultilineStr = '''My Line 1,
  mySecondLine
  my last line'''

  str01 = 'Hello world!'  
  str01.startswith('Hello')   # True
  str01. endswith ('world!')  # True
  str01[0]     # 'H'        
  str01[0:5]   # 'Hello'
  str01[::-1]  # '!dlrow olleH'
  'Hello' in str01  # True    
  'HELLO' in str01  # False   
  str01.upper()   # 'HELLO WORLD!'
  str01.lower()   # 'hello world!'
  str01.islower() # False
  str01.isupper() # False
  str01.upper().isupper()  # True
  str01.isalpha()  # True if str01 have only letters and is not blank.
  str01.isalnum()  # True if str01 have only lettersand numbers and is not blank.
  str01.isdecimal()# True if str01 have only numeric characters and is not blank.
  str01.isspace()  # True if str01 have only spaces,tabs, and new-lines and is not blank.
  str01.istitle()  # True if str01 have words begining with uppercase letter followed 
                   # by only lowercase letters.
  ', '. join (['a', 'b', 'c']) # 'a, b, c'
  'a b c'. split()             # ['a', 'b', 'c']

  # ------ Justifying Text (Tabular Text!!!) ------
  '1234'. rjust  (10,'+') # '+++++1234'                
  '1234'. ljust  (10,'-') # '1234-----'
  '1234'. center (10,'|') # '|||||||Hello|||||||'
  #                  └─┴·····Optional(' ' by default)

  # ------ Removing Whitespaces ------
  '    Hello World     '.  strip()   # 'Hello World'       
  '    Hello World     '. lstrip()   # 'Hello World     '
  '    Hello World     '. rstrip()   # '     Hello World'
  'Hello World '

  import re  
  regex01 = '[!@#$%^&*(),.?":{}|<>]'
  output_str = re.sub(regex01, '', input_str) # Replace using regex.

  # ------ Lazy formatting -------
  # Formatted String Literals f-strings  Python 3.6+
  name = 'Elizabeth'
  'Hello {name}!'   # 'Hello Elizabeth!
  'result: {myIntVar01 + myIntVar02}'

  # ------ Template Strings -------
  (simpler, less powerful)
  from string import Template
  name = 'Elizabeth'
  t = Template('Hey $name!')
  t.substitute(name=name)
  'Hey Elizabeth!'
  ```

## textwrap lib  [[{PM.TODO]]

* <https://docs.python.org/2/library/textwrap.html>
[[PM.TODO}]]
[[101.strings}]]

# Regex [[{]]
- Import the regex module with import re.
- Create a Regex object with the re.compile() function. (Remember to use a raw string.)
- Pass the string you want to search into the Regex object's search() method.
  This returns a Match object.

import  re   # Step 1
phone_num_regex = re. compile (r'\d\d\d-\d\d\d-\d\d\d\d')  # step 2. Create regex object
                             ^
                             raw string

mo = phone_num_regex. search ('My number is 415-555-4242.') # step 3.
^^                           ^^^^^^^^^^^^^^^^^^^^^^^^^
Object of type "Match"       Input string to search against

print('Phone number found: {}'.format(mo. group ()))        # step 4. show results
                                         ^^^^^
                                         returns actual matched text string
                                         (415-555-4242)

 Grouping with Parentheses
phone_num_regex = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')  # step 2
mo = phone_num_regex.search('My number is 415-555-4242.')    # step 3
mo.group(1)                                                  # '415'
mo.group(2)                                                  # '555-4242'
mo.group(0)                                                  # '415-555-4242'
mo.group()                                                   # '415-555-4242'
mo.groups()                                                  # ('415', '555-4242')

Other regext examples:
r'wom(a|e)n'  # | == or        (match woman or women)
r'(wo)?man'   # ? == optional  (match man  or woman )
r'(wo) man'   #   == 0 or more (match man  or woman or wowoman or ... )
r'(wo)+man'   # + == 1 or more (match         woman or wowoman or ... )
r'(wo){2}man' # {2} == 2 time  (match                  wowoman )

 Greedy vs Nongreedy Matching

Python’s regular expressions are greedy by default, which means
that in ambiguous situations they will match the longest string
possible. The non-greedy version of the curly brackets, which matches
the shortest string possible, has the closing curly bracket followed
by a question mark.

>>> greedy_ha_regex = re.compile(r'(Ha){3,5}')
>>> mo1 = greedy_ha_regex.search('HaHaHaHaHa')
>>> mo1.group()
'HaHaHaHaHa'

>>> nongreedy_ha_regex = re.compile(r'(Ha){3,5}?')
>>> mo2 = nongreedy_ha_regex.search('HaHaHaHaHa')
>>> mo2.group()
'HaHaHa'

The findall Method

In addition to the search() method, Regex objects also have a
findall() method. While search() will return a Match object of the
first matched text in the searched string, the findall() method will
return the strings of every match in the searched string.

>>> phone_num_regex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') # has no groups

>>> phone_num_regex.findall('Cell: 415-555-9999 Work: 212-555-0000')
['415-555-9999', '212-555-0000']

To summarize what the findall() method returns, remember the following:

    When called on a regex with no groups, such as
\d-\d\d\d-\d\d\d\d, the method findall() returns a list of ng
matches, such as ['415-555-9999', '212-555-0000'].

    When called on a regex that has groups, such as
(\d\d\d)-d\d)-(\d\ d\d\d), the method findall() returns a list of es
of strings (one string for each group), such as [('415', ', '9999'),
('212', '555', '0000')].

Making Your Own Character Classes

There are times when you want to match a set of characters but the
shorthand character classes (\d, \w, \s, and so on) are too broad.
You can define your own character class using square brackets. For
example, the character class [aeiouAEIOU] will match any vowel, both
lowercase and uppercase.

>>> vowel_regex = re.compile(r'[aeiouAEIOU]')

>>> vowel_regex.findall('Robocop eats baby food. BABY FOOD.')
['o', 'o', 'o', 'e', 'a', 'a', 'o', 'o', 'A', 'O', 'O']

You can also include ranges of letters or numbers by using a hyphen.
For example, the character class [a-zA-Z0-9] will match all lowercase
letters, uppercase letters, and numbers.

By placing a caret character (^) just after the character class’s
opening bracket, you can make a negative character class. A negative
character class will match all the characters that are not in the
character class. For example, enter the following into the
interactive shell:

>>> consonant_regex = re.compile(r'[^aeiouAEIOU]')

>>> consonant_regex.findall('Robocop eats baby food. BABY FOOD.')
['R', 'b', 'c', 'p', ' ', 't', 's', ' ', 'b', 'b', 'y', ' ', 'f',
'd', '.', '
', 'B', 'B', 'Y', ' ', 'F', 'D', '.']

The Caret and Dollar Sign Characters

    You can also use the caret symbol (^) at the start of a regex to
indicate that a match must occur at the beginning of the searched
text.

    Likewise, you can put a dollar sign ($) at the end of the regex
to indicate the string must end with this regex pattern.

    And you can use the ^ and $ together to indicate that the entire
string must match the regex—that is, it’s not enough for a match
to be made on some subset of the string.

The r'^Hello' regular expression string matches strings that begin
with 'Hello':

>>> begins_with_hello = re.compile(r'^Hello')

>>> begins_with_hello.search('Hello world!')
<_sre.SRE_Match object; span=(0, 5), match='Hello'>

>>> begins_with_hello.search('He said hello.') is None
True

The r'\d$' regular expression string matches strings that end with a numeric character from 0 to 9:

>>> whole_string_is_num = re.compile(r'^\d+$')

>>> whole_string_is_num.search('1234567890')
<_sre.SRE_Match object; span=(0, 10), match='1234567890'>

>>> whole_string_is_num.search('12345xyz67890') is None
True

>>> whole_string_is_num.search('12 34567890') is None
True

The Wildcard Character

The . (or dot) character in a regular expression is called a wildcard and will match any character except for a newline:

>>> at_regex = re.compile(r'.at')

>>> at_regex.findall('The cat in the hat sat on the flat mat.')
['cat', 'hat', 'sat', 'lat', 'mat']

Matching Everything with Dot-Star

>>> name_regex = re.compile(r'First Name: (. ) Last Name: (. )')

>>> mo = name_regex.search('First Name: Al Last Name: Sweigart')

>>> mo.group(1)
'Al'

>>> mo.group(2)
'Sweigart'

The dot-star uses greedy mode: It will always try to match as much
text as possible. To match any and all text in a nongreedy fashion,
use the dot, star, and question mark (.*?). The question mark tells
Python to match in a nongreedy way:

>>> nongreedy_regex = re.compile(r'<.*?>')
>>> mo = nongreedy_regex.search('<To serve man> for dinner.>')
>>> mo.group()
'<To serve man>'

>>> greedy_regex = re.compile(r'<.*>')
>>> mo = greedy_regex.search('<To serve man> for dinner.>')
>>> mo.group()
'<To serve man> for dinner.>'

Matching Newlines with the Dot Character

The dot-star will match everything except a newline. By passing
re.DOTALL as the second argument to re.compile(), you can make the
dot character match all characters, including the newline character:

>>> no_newline_regex = re.compile('.*')
>>> no_newline_regex.search('Serve the public trust.\nProtect the innocent.\nUphold the law.').group()
'Serve the public trust.'

>>> newline_regex = re.compile('.*', re.DOTALL)
>>> newline_regex.search('Serve the public trust.\nProtect the innocent.\nUphold the law.').group()
'Serve the public trust.\nProtect the innocent.\nUphold the law.'

Review of Regex Symbols
Symbol  Matches
?   zero or one of the preceding group.
*   zero or more of the preceding group.
+   one or more of the preceding group.
{n}     exactly n of the preceding group.
{n,}    n or more of the preceding group.
{,m}    0 to m of the preceding group.
{n,m}   at least n and at most m of the preceding p.
{n,m}? or *? or +?  performs a nongreedy match of the preceding p.
^spam   means the string must begin with spam.
spam$   means the string must end with spam.
.   any character, except newline characters.
\d, \w, and \s  a digit, word, or space character, resectively.
\D, \W, and \S  anything except a digit, word, or space acter, respectively.
[abc]   any character between the brackets (such as a, b, ).
[^abc]  any character that isn’t between the brackets.
Case-Insensitive Matching

To make your regex case-insensitive, you can pass re.IGNORECASE or
re.I as a second argument to re.compile():

>>> robocop = re.compile(r'robocop', re.I)

>>> robocop.search('Robocop is part man, part machine, all cop.').group()
'Robocop'

>>> robocop.search('ROBOCOP protects the innocent.').group()
'ROBOCOP'

>>> robocop.search('Al, why does your programming book talk about robocop so much?').group()
'robocop'

Substituting Strings with the sub() Method

The sub() method for Regex objects is passed two arguments:

    The first argument is a string to replace any matches.
    The second is the string for the regular expression.

The sub() method returns a string with the substitutions applied:

>>> names_regex = re.compile(r'Agent \w+')

>>> names_regex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.')
'CENSORED gave the secret documents to CENSORED.'

Another example:

>>> agent_names_regex = re.compile(r'Agent (\w)\w*')

>>> agent_names_regex.sub(r'\     ', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.')
      told       that       knew       was a double agent.'

Managing Complex Regexes

To tell the re.compile() function to ignore whitespace and comments
inside the regular expression string, “verbose mode” can be
enabled by passing the variable re.VERBOSE as the second argument to
re.compile().

Now instead of a hard-to-read regular expression like this:

phone_regex = re.compile(r'((\d{3}|\(\d{3}\))?(\s|-|\.)?\d{3}(\s|-|\.)\d{4}(\s*(ext|x|ext.)\s*\d{2,5})?)')

you can spread the regular expression over multiple lines with comments like this:

phone_regex = re.compile(r'''(
    (\d{3}|\(\d{3}\))?            # area code
    (\s|-|\.)?                    # separator
    \d{3}                         # first 3 digits
    (\s|-|\.)                     # separator
    \d{4}                         # last 4 digits
    (\s*(ext|x|ext.)\s*\d{2,5})?  # extension
    )''', re.VERBOSE)
[[}]]
```
<!-- } -->


# Python Modules [[{qa,devops]]

```
alt 1                          alt 2
import random, sys, os, math   from random import *.
print(random.randint(1, 10))   print(randint(1, 10))

 __main__
Top-level script environment

__main__ is the name of the scope in which top-level code executes. A
module’s name is set equal to __main__ when read from standard
input, a script, or from an interactive prompt.

A module can discover whether or not it is running in the main scope
by checking its own __name__, which allows a common idiom for
conditionally executing code in a module when it is run as a script
or with python -m but not when it is imported:

>>> if __name__ == "__main__":
...     # execute only if run as a script
...     main()

For a package, the same effect can be achieved by including a main.py
module, the contents of which will be executed when the module is run
with -m.

For example we are developing script which is designed to be used as
module, we should do:

>>> # Python program to execute function directly
>>> def add(a, b):
...     return a+b
...
>>> add(10, 20) # we can test it by calling the function save it as calculate.py
30
>>> # Now if we want to use that module by importing we have to comment out our call,
>>> # Instead we can write like this in calculate.py
>>> if __name__ == "__main__":
...     add(3, 5)
...
>>> import calculate
>>> calculate.add(3, 5)
8

Advantages
  Every Python module has it’s __name__ defined and if this is
  __main__, it implies that the module is being run standalone by the
  user and we can do corresponding appropriate actions.
  If you import this script as a module in another script, the name
  is set to the name of the script/module.
  Python files can act as either reusable modules, or as standalone
  programs.
  if __name__ == “main”: is used to execute some code only if
   the file was run directly, and not imported.

 sys module
import sys
sys.exit()
```
[[}]]
